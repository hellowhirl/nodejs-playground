NodeJS notes

About NodeJS
- a runtime environment for executing JavaScript code
- Ideal for building highly-scalable, data-intensive and real-time applications
- Great for prototyping and agile development
- Superfast and highly scalable companies (build backends with less code and can increase request speed)
- JavaScript everywhere (reuse JS skills)
- Cleaner and more consistent code with JavaScript- Large ecosystem of open-source libs

Architecture of Node
- Ryan Dahl, embedded Chrome v8 engine in a C++ program and called in Node
- There is no 'document' object or 'window' object; however, comes with objects like 'fs' for file system,'http' for listening, and network and file system
    - these extra capabilities are not available inside browsers
- "I prefer Node to C#" is fundamentally wrong - Node is NOT a programming language
    - it's a runtime environment for executing JavaScript code

How Node works
- Asynchronous: non-blocking architecture (Node by default)
- Synchronous: blocking architecture (how ASP.net and Rails work out of the box)
- In Node we have a single thread to handle all requests - will move on from one client to the next without waiting for response from DB
- When the DB prepares the result it puts the message in an 'Event Queue' 
    - Node continually monitors this queue in the backgground, when it finds an event in this queue it will take it out and process it
- Node is ideal for I/O-intensive apps (a lot of disk or network access) - able to serve more clients without need for more hardware
- Do not use Node for CPU-intensive apps (video encoding or image manipulation)
- We can write regular JavaScript, just like how we write for browsers

Example:
    $ node test-app.js


Module Wrapper Function:

- Node does not execute our code directly - it always wraps the code in each module with an IIFE function like below to create scope:
(function(exports, require, module, __filename, dirname) { 
    <code inside module> 
})

- 'require' appears to be globally but actually it's not - it's local to each module
- 'require' and others listed are arguments we pass to the function for our module


Node Module System: (built-in modules in Node)

- OS, File System, events, HTTP, Path, Process, Query Strings, Stream, etc. 
- To work with files and directories in Node first we need to 'require' the 'fs' module and then use the File System Module method(s) - always prefer to use asynchronous methods

Events
- a lot of Node's core functionality is based on events (EventEmitter is the core class)
- an event is a signal that incdicates that something has happened in our application
- Example: listening for requests from an HTTP class on a given port, everytime we receive a request from that port that HTTP class raises an event - our job is to respond that event which involes reading that request and returning the right response

- whenever we want to raise events in our application to signal that something has happened, we need to create a Class that extends EventEmitter. But we can also add additional functionality (like a 'log' method). Then whenever we want to raise an event we use 'this.emit' because it references the class being used, which is an extension of EventEmitter.
- Then, in a separate module (like 'app.js') we will use an instance of the custom class we have defined that extends EventEmitter. And then we can use the '.on' method which will register an event listener.

In summary: to create a class with the ability to raise events, we should extend EventEmitter: 
class Logger extends EventEmitter { } 

Http Module
- used for creating networking applications
- Several built-in classes in Node derive from EventEmitter like net.Server (which http.Server inherits from)
- we use the Express framework to handle various routes, which givves our application a clean structure. Internally Epxress is built on top of the http module in Node

NPM
- for pretty much any kind of functionality there is most likely a free open source library available on NPM
- when you install node you also get npm

package.json
- a bunch of metadata about your application (key/value pairs)
- best practice: whenever you start a node project run '$ npm -init' to create 'package.json'
- whenever we install a new package via npm it is inserted into 'package.json' under 'dependencies'
- every node module has a 'package.json' file, just like our application
- also we can see the name of this dev dependency under 'node_modules' folder
- in later version of npm we don't need to supply the --save flag anymore, just '$ npm i library-name'